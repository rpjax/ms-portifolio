using System.Collections.Concurrent;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Text;

namespace ModularSystem.Core.Reflection;

/// <summary>
/// Provides functionalities for dynamic type creation, including the generation of anonymous types.
/// </summary>
public static class TypeCreator
{
    /// <summary>
    /// The default prefix used for naming dynamically created anonymous types.
    /// </summary>
    /// <remarks>
    /// This prefix is utilized when a specific name is not provided for the anonymous type.
    /// It follows the naming convention used by the C# compiler for generated anonymous types.
    /// </remarks>
    public const string AnonymousTypePrefix = "<>f__AnonymousType";

    private static ConcurrentDictionary<string, Type> Cache = new();

    /// <summary>
    /// Dynamically creates an anonymous type based on the provided properties. 
    /// This method allows for the creation of types with customizable properties, 
    /// including the option to have setters and a default constructor.
    /// It is particularly useful in scenarios where types need to be defined at runtime.
    /// </summary>
    /// <param name="properties">An array of <see cref="AnonymousPropertyDefinition"/> defining the properties of the anonymous type.</param>
    /// <param name="options">An instance of <see cref="AnonymousTypeCreationOptions"/> specifying options like name, setters, and constructor.</param>
    /// <returns>A new dynamically created type that represents the defined anonymous type.</returns>
    /// <remarks>
    /// Utilizes <see cref="System.Reflection.Emit.AssemblyBuilder"/> and <see cref="System.Reflection.Emit.ModuleBuilder"/>
    /// to create a type at runtime, resembling C# compiler-created anonymous types with added flexibility.
    /// </remarks>
    public static Type CreateAnonymousType(AnonymousPropertyDefinition[] properties, AnonymousTypeCreationOptions? options = null)
    {
        options ??= new();

        var signatureKey = CreateSignatureKey(properties);

        if (options.UseCache && Cache.ContainsKey(signatureKey))
        {
            return Cache[signatureKey];
        }

        var name = options.Name;
        var createSetters = options.CreateSetters;

        // Cria um assembly dinâmico
        var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName("DynamicAssembly"), AssemblyBuilderAccess.Run);
        var moduleBuilder = assemblyBuilder.DefineDynamicModule("DynamicModule");

        // Cria um tipo dinâmico
        var typeBuilder = moduleBuilder.DefineType($"{name}", TypeAttributes.Public);

        // Define os campos
        var fieldBuilders = new FieldBuilder[properties.Length];

        // Defines some data notations attributes that exists in a real anonymous type generated by the compiler.
        typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(
            typeof(CompilerGeneratedAttribute).GetConstructor(Type.EmptyTypes)!, Array.Empty<object>()));

        typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(
            typeof(DebuggerDisplayAttribute).GetConstructor(new[] { typeof(string) })!, new object[] { "{ToString()}" }));


        for (int i = 0; i < properties.Length; i++)
        {
            fieldBuilders[i] = typeBuilder.DefineField($"<{properties[i].Name}>k__BackingField", properties[i].Type, FieldAttributes.Private);
        }

        if (options.CreateDefaultConstructor)
        {
            // default constructor
            var defaultConstructorBuilder = typeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, Type.EmptyTypes);
            var defaultConstructorGenerator = defaultConstructorBuilder.GetILGenerator();

            defaultConstructorGenerator.Emit(OpCodes.Ret);
        }

        // Define o construtor
        var constructorBuilder = typeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, properties.Select(p => p.Type).ToArray());

        var ctorIL = constructorBuilder.GetILGenerator();

        for (int i = 0; i < properties.Length; i++)
        {
            ctorIL.Emit(OpCodes.Ldarg_0); // Carrega o this
            ctorIL.Emit(OpCodes.Ldarg, i + 1); // Carrega o argumento (1-indexado)
            ctorIL.Emit(OpCodes.Stfld, fieldBuilders[i]); // Define o campo
        }

        ctorIL.Emit(OpCodes.Ret);

        // Define as propriedades e seus acessadores
        for (int i = 0; i < properties.Length; i++)
        {
            var propertyBuilder = typeBuilder.DefineProperty(properties[i].Name, PropertyAttributes.HasDefault, properties[i].Type, null);

            // Define o getter
            var getterMethodBuilder = typeBuilder.DefineMethod($"get_{properties[i].Name}", MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig, properties[i].Type, Type.EmptyTypes);
            var getterIL = getterMethodBuilder.GetILGenerator();

            getterIL.Emit(OpCodes.Ldarg_0);
            getterIL.Emit(OpCodes.Ldfld, fieldBuilders[i]);
            getterIL.Emit(OpCodes.Ret);
            propertyBuilder.SetGetMethod(getterMethodBuilder);

            if (createSetters)
            {
                var setterMethodBuilder = typeBuilder.DefineMethod($"set_{properties[i].Name}", MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig, null, new[] { properties[i].Type });
                var setterIL = setterMethodBuilder.GetILGenerator();

                setterIL.Emit(OpCodes.Ldarg_0);
                setterIL.Emit(OpCodes.Ldarg_1);
                setterIL.Emit(OpCodes.Stfld, fieldBuilders[i]);
                setterIL.Emit(OpCodes.Ret);
                propertyBuilder.SetSetMethod(setterMethodBuilder);
            }
        }

        // Cria o tipo
        var type = typeBuilder.CreateType();

        if (type == null)
        {
            throw new Exception();
        }

        if (options.UseCache)
        {
            Cache.AddOrUpdate(signatureKey, type, (key, current) => type);
        }

        return type;
    }

    /// <summary>
    /// Overload of <see cref="CreateAnonymousType(AnonymousPropertyDefinition[], AnonymousTypeCreationOptions)"/> for creating an anonymous type from an enumerable of property definitions.
    /// This method simplifies the creation of anonymous types by allowing the use of an IEnumerable for property definitions.
    /// </summary>
    /// <param name="properties">An enumerable of <see cref="AnonymousPropertyDefinition"/> for defining the properties of the anonymous type.</param>
    /// <param name="options">Optional settings for creating the anonymous type, such as name, setters, and constructor.</param>
    /// <returns>A new dynamically created type that represents the defined anonymous type.</returns>
    public static Type CreateAnonymousType(IEnumerable<AnonymousPropertyDefinition> properties, AnonymousTypeCreationOptions? options = null)
    {
        return CreateAnonymousType(properties.ToArray(), options);
    }

    private static string CreateSignatureKey(AnonymousPropertyDefinition[] propertyDefinitions)
    {
        var keyBuilder = new StringBuilder();

        foreach (var propertyDefinition in propertyDefinitions)
        {
            keyBuilder.Append('[');
            keyBuilder.Append(propertyDefinition.Name);
            keyBuilder.Append(propertyDefinition.Type.GetQualifiedFullName());
            keyBuilder.Append(']');
        }

        return keyBuilder.ToString();
    }

}

/// <summary>
/// Represents options for creating dynamic anonymous types with additional caching feature.
/// </summary>
public class AnonymousPropertyDefinition
{
    /// <summary>
    /// Gets the name of the property.
    /// </summary>
    public string Name { get; }

    /// <summary>
    /// Gets the type of the property.
    /// </summary>
    public Type Type { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="AnonymousPropertyDefinition"/> class.
    /// </summary>
    /// <param name="name">The name of the property.</param>
    /// <param name="type">The type of the property.</param>
    public AnonymousPropertyDefinition(string name, Type type)
    {
        Name = name;
        Type = type;
    }
}

/// <summary>
/// Provides options for customizing the creation of dynamic anonymous types.
/// </summary>
public class AnonymousTypeCreationOptions
{
    /// <summary>
    /// Gets or sets the name to be used for the dynamically created anonymous type.
    /// </summary>
    /// <remarks>
    /// Defaults to a generic anonymous type name if not set.
    /// </remarks>
    public string Name { get; set; } = TypeCreator.AnonymousTypePrefix;

    /// <summary>
    /// Indicates whether to use a cache for storing and reusing dynamically created types. <br/>
    /// When set to true, types with the same structure are retrieved from cache instead of being recreated, <br/>
    /// optimizing performance for repeated type creations.
    /// </summary>
    /// <remarks>
    /// Caching is particularly beneficial when similar anonymous types are created multiple times throughout the application lifecycle.
    /// </remarks>
    public bool UseCache { get; set; } = true;

    /// <summary>
    /// Gets or sets a value indicating whether to include a default constructor in the anonymous type.
    /// </summary>
    public bool CreateDefaultConstructor { get; set; } = false;

    /// <summary>
    /// Gets or sets a value indicating whether to create setters for the properties of the anonymous type.
    /// </summary>
    /// <remarks>
    /// Setters allow for modification of the property values after the object has been instantiated.
    /// </remarks>
    public bool CreateSetters { get; set; } = false;
}

