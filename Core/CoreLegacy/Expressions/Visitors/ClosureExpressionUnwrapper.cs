using System.Linq.Expressions;

namespace ModularSystem.Core.Expressions;

/// <summary>
/// Provides functionality to unwrap closure expressions, extracting the underlying values from captured variables.
/// </summary>
/// <remarks>
/// Closure expressions are generated by the C# compiler to represent variables that are captured by lambda expressions.
/// This unwrapper traverses the expression tree, identifies closure expressions, and replaces them with constant expressions
/// that hold the captured values, making it easier to analyze and manipulate the expression tree.
/// </remarks>
public class ClosureExpressionUnwrapper : ExpressionVisitor
{
    /// <summary>
    /// Visits the children of the <see cref="MemberExpression"/> and unwraps any closure expressions found.
    /// </summary>
    /// <param name="node">The expression to visit.</param>
    /// <returns>
    /// A modified expression, if the provided expression was a closure expression; otherwise, the original expression.
    /// </returns>
    /// <exception cref="InvalidOperationException">
    /// Thrown when the provided expression does not have a valid sub-expression or when the sub-expression type is not of type 'Constant'.
    /// </exception>
    /// <exception cref="Exception">
    /// Thrown when the value of the constant expression is null or when the value of the property from the anonymous object cannot be retrieved.
    /// </exception>
    protected override Expression VisitMember(MemberExpression node)
    {
        if (node.Member.DeclaringType == null || !node.Member.DeclaringType.Name.StartsWith("<>"))
        {
            return base.VisitMember(node);
        }
        if (node.Expression == null)
        {
            throw new InvalidOperationException("The provided expression does not have a valid sub-expression.");
        }
        if (node.Expression.NodeType != ExpressionType.Constant)
        {
            throw new InvalidOperationException("The sub-expression type is not of type 'Constant'.");
        }

        var constantExpression = node.Expression.TryTypeCast<ConstantExpression>();

        if (constantExpression == null)
        {
            throw new InvalidOperationException("Failed to cast the sub-expression to 'ConstantExpression'.");
        }

        var annonymousObject = constantExpression.Value;

        if (annonymousObject == null)
        {
            throw new Exception("The value of the constant expression is null.");
        }

        var capturedValue = annonymousObject
            .GetType()
            .GetField(node.Member.Name)
            ?.GetValue(annonymousObject);

        if (capturedValue == null)
        {
            throw new Exception($"Failed to retrieve the value of the property '{node.Member.Name}' from the anonymous object.");
        }

        return Expression.Constant(capturedValue, node.Type);
    }
}