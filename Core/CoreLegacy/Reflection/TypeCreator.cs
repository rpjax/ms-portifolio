using ModularSystem.Core.Threading;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Text;

namespace ModularSystem.Core.Reflection;

/// <summary>
/// Provides functionalities for dynamic type creation, including the generation of anonymous types.
/// </summary>
public static class TypeCreator
{
    /// <summary>
    /// The default prefix used for naming dynamically created anonymous types.
    /// </summary>
    /// <remarks>
    /// This prefix is utilized when a specific name is not provided for the anonymous type.
    /// It follows the naming convention used by the C# compiler for generated anonymous types.
    /// </remarks>
    public const string AnonymousTypeDefaultName = "<>f__AnonymousType";

    private static ConcurrentDictionary<string, Type> Cache = new();

    //*
    // Define a significantly large threshold for the cache size to accommodate the needs of
    // long-running applications that extensively use anonymous types.
    // This routine serves as a safeguard against potential memory leaks due to unchecked growth of the dictionary.
    // With an estimated average size of 2 KB per 'Type' instance, a cache with 100,000 entries
    // would occupy approximately 195.3 MB (100,000 * 2 KB ≈ 195.3 MB).
    // Therefore, the cache is capped to limit its size to around 200 megabytes.
    // This aproach is straightforward, but may have to be revised in the future.
    //*
    private static TaskRoutine CacheResetRoutine { get; }
        = new LambdaTaskRoutine(TimeSpan.FromDays(1), async (cancellationToken) =>
        {
            if (Cache.Count > 100_000)
            {
                Cache.Clear();
            }
        })
        .Start();

    /// <summary>
    /// Dynamically creates an anonymous type based on the properties and options provided.<br/> 
    /// This method facilitates the creation of types with customizable properties, <br/>
    /// including options for setters, a default constructor, and generic type arguments.<br/>
    /// It is especially useful in scenarios where types need to be defined at runtime.
    /// </summary>
    /// <param name="options">An instance of <see cref="AnonymousTypeCreationOptions"/> specifying the properties <br/>
    /// and options for the anonymous type, such as name, setters, constructor, and generic type arguments.</param>
    /// <returns>A new dynamically created type that represents the defined anonymous type.</returns>
    /// <remarks>
    /// Utilizes <see cref="System.Reflection.Emit.AssemblyBuilder"/> and <see cref="System.Reflection.Emit.ModuleBuilder"/><br/>
    /// to construct a type at runtime. This approach offers flexibility similar to C# compiler-created anonymous types,<br/>
    /// but with added customization capabilities provided by the options.
    /// </remarks>
    public static Type CreateAnonymousType(AnonymousTypeCreationOptions? options = null)
    {
        options ??= new();

        var properties = options.Properties.ToArray();
        var signatureKey = CreateSignatureKey(options);

        if (options.UseCache && Cache.ContainsKey(signatureKey))
        {
            return Cache[signatureKey];
        }

        var createSetters = options.CreateSetters;

        // Cria um assembly dinâmico
        var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(
            new AssemblyName("DynamicAssembly"),
            AssemblyBuilderAccess.RunAndCollect
        );

        var moduleBuilder = assemblyBuilder.DefineDynamicModule("DynamicModule");

        // Cria um tipo dinâmico
        var typeBuilder = moduleBuilder.DefineType($"{options.Name}", TypeAttributes.Public);

        // Adiciona argumentos de tipo genérico, se existirem
        if (options.GenericTypeArguments.Length > 0)
        {
            var genericTypeNames = options.GenericTypeArguments
                .Select((_, i) => $"T{i}")
                .ToArray();

            var genericTypeParameters = typeBuilder.DefineGenericParameters(genericTypeNames);

            for (int i = 0; i < genericTypeParameters.Length; i++)
            {
                //*
                // TODO: Type Constraints
                //*
            }
        }

        // Define os campos
        var fieldBuilders = new FieldBuilder[properties.Length];

        // Defines some data notations attributes that exists in a real anonymous type generated by the compiler.
        typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(
            typeof(CompilerGeneratedAttribute)
                .GetConstructor(Type.EmptyTypes)!,
            Array.Empty<object>()
        ));

        typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(
            typeof(DebuggerDisplayAttribute)
                .GetConstructor(new[] { typeof(string) })!,
            new object[] { "{ToString()}" }
        ));


        for (int i = 0; i < properties.Length; i++)
        {
            fieldBuilders[i] = typeBuilder.DefineField(
                $"<{properties[i].Name}>k__BackingField",
                properties[i].Type,
                FieldAttributes.Private
            );
        }

        if (options.CreateDefaultConstructor)
        {
            // default constructor
            var defaultConstructorBuilder = typeBuilder.DefineConstructor(
                MethodAttributes.Public,
                CallingConventions.Standard, Type.EmptyTypes
            );

            var defaultConstructorGenerator = defaultConstructorBuilder.GetILGenerator();

            defaultConstructorGenerator.Emit(OpCodes.Ret);
        }

        // Define o construtor
        var constructorBuilder = typeBuilder.DefineConstructor(
            MethodAttributes.Public,
            CallingConventions.Standard,
            properties.Select(p => p.Type).ToArray()
        );

        var ctorIL = constructorBuilder.GetILGenerator();

        for (int i = 0; i < properties.Length; i++)
        {
            ctorIL.Emit(OpCodes.Ldarg_0); // Carrega o this
            ctorIL.Emit(OpCodes.Ldarg, i + 1); // Carrega o argumento (1-indexado)
            ctorIL.Emit(OpCodes.Stfld, fieldBuilders[i]); // Define o campo
        }

        ctorIL.Emit(OpCodes.Ret);

        // Define as propriedades e seus acessadores
        for (int i = 0; i < properties.Length; i++)
        {
            var propertyBuilder = typeBuilder.DefineProperty(
                properties[i].Name,
                PropertyAttributes.HasDefault,
                properties[i].Type,
                null
            );

            // Define o getter
            var getterMethodBuilder = typeBuilder.DefineMethod(
                $"get_{properties[i].Name}",
                MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig,
                properties[i].Type,
                Type.EmptyTypes
            );
            var getterIL = getterMethodBuilder.GetILGenerator();

            getterIL.Emit(OpCodes.Ldarg_0);
            getterIL.Emit(OpCodes.Ldfld, fieldBuilders[i]);
            getterIL.Emit(OpCodes.Ret);
            propertyBuilder.SetGetMethod(getterMethodBuilder);

            if (createSetters)
            {
                var setterMethodBuilder = typeBuilder.DefineMethod(
                    $"set_{properties[i].Name}",
                    MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig,
                    null, new[] { properties[i].Type }
                );
                var setterIL = setterMethodBuilder.GetILGenerator();

                setterIL.Emit(OpCodes.Ldarg_0);
                setterIL.Emit(OpCodes.Ldarg_1);
                setterIL.Emit(OpCodes.Stfld, fieldBuilders[i]);
                setterIL.Emit(OpCodes.Ret);
                propertyBuilder.SetSetMethod(setterMethodBuilder);
            }
        }

        // Cria o tipo
        var type = typeBuilder.CreateType();

        if (type == null)
        {
            throw new Exception();
        }

        if (options.GenericTypeArguments.Length > 0)
        {
            type = type.MakeGenericType(options.GenericTypeArguments);
        }

        if (options.UseCache)
        {
            Cache.AddOrUpdate(signatureKey, type, (key, current) => type);
        }

        return type;
    }

    private static string CreateSignatureKey(AnonymousTypeCreationOptions options)
    {
        var keyBuilder = new StringBuilder();
        var propertyDefinitions = options.Properties;

        var genericsTokens = new List<string>();
        var propsTokens = new List<string>();
        var settingsTokens = new List<string>();

        //*
        // generics section
        //*
        if (options.GenericTypeArguments.IsNotEmpty())
        {
            foreach (var type in options.GenericTypeArguments)
            {
                genericsTokens.Add(type.FullName ?? type.Name);
            }

            keyBuilder.Append('<');
            keyBuilder.Append(string.Join(", ", genericsTokens));
            keyBuilder.Append('>');
        }

        //*
        // properties section
        //*
        foreach (var propDefinition in propertyDefinitions)
        {
            var type = propDefinition.Type.FullName ?? propDefinition.Type.Name;
            var name = propDefinition.Name;

            propsTokens.Add($"{type} {name}");
        }

        keyBuilder.Append('(');
        keyBuilder.Append(string.Join(", ", propsTokens));
        keyBuilder.Append(')');

        //*
        // settings section
        //*
        settingsTokens.Add($"defcon: {options.CreateDefaultConstructor}");
        settingsTokens.Add($"setters: {options.CreateSetters}");

        keyBuilder.Append('[');
        keyBuilder.Append(string.Join("; ", settingsTokens));
        keyBuilder.Append(']');

        return keyBuilder.ToString();
    }

}

/// <summary>
/// Represents options for creating dynamic anonymous types with additional caching feature.
/// </summary>
public class AnonymousPropertyDefinition
{
    /// <summary>
    /// Gets the name of the property.
    /// </summary>
    public string Name { get; }

    /// <summary>
    /// Gets the type of the property.
    /// </summary>
    public Type Type { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="AnonymousPropertyDefinition"/> class.
    /// </summary>
    /// <param name="name">The name of the property.</param>
    /// <param name="type">The type of the property.</param>
    public AnonymousPropertyDefinition(string name, Type type)
    {
        Name = name;
        Type = type;
    }
}

/// <summary>
/// Provides options for customizing the creation of dynamic anonymous types.
/// </summary>
public class AnonymousTypeCreationOptions
{
    /// <summary>
    /// Gets or sets the name to be used for the dynamically created anonymous type.
    /// </summary>
    /// <remarks>
    /// Defaults to a generic anonymous type name if not set.
    /// </remarks>
    public string Name { get; set; } = TypeCreator.AnonymousTypeDefaultName;

    /// <summary>
    /// Provides a collection of property definitions for the dynamically created anonymous type.
    /// </summary>
    /// <remarks>
    /// Each property definition in this collection includes the name and type of the property. <br/>
    /// This collection dictates the structure of the anonymous type by specifying the properties it will contain.
    /// </remarks>
    public IEnumerable<AnonymousPropertyDefinition> Properties { get; set; }
        = Array.Empty<AnonymousPropertyDefinition>();

    /// <summary>
    /// Gets or sets the generic type arguments for the dynamically created anonymous type.
    /// </summary>
    /// <remarks>
    /// This array of <see cref="Type"/> objects represents the generic type arguments <br/>
    /// to be applied to the anonymous type. If no generic type arguments are specified, <br/>
    /// the anonymous type will be non-generic. This feature allows for the creation <br/>
    /// of generic anonymous types, enhancing their flexibility and applicability <br/>
    /// in scenarios where generic functionality is required.
    /// </remarks>
    public Type[] GenericTypeArguments { get; set; } = Array.Empty<Type>();

    /// <summary>
    /// Indicates whether to use a cache for storing and reusing dynamically created types. <br/>
    /// When set to true, types with the same structure are retrieved from cache instead of being recreated, <br/>
    /// optimizing performance for repeated type creations.
    /// </summary>
    /// <remarks>
    /// Caching is particularly beneficial when similar anonymous types are created multiple times throughout the application lifecycle.
    /// </remarks>
    public bool UseCache { get; set; } = true;

    /// <summary>
    /// Gets or sets a value indicating whether to include a default constructor in the anonymous type.
    /// </summary>
    public bool CreateDefaultConstructor { get; set; } = false;

    /// <summary>
    /// Gets or sets a value indicating whether to create setters for the properties of the anonymous type.
    /// </summary>
    /// <remarks>
    /// Setters allow for modification of the property values after the object has been instantiated.
    /// </remarks>
    public bool CreateSetters { get; set; } = false;

    /// <summary>
    /// Initializes a new instance of the <see cref="AnonymousTypeCreationOptions"/> class.
    /// </summary>
    public AnonymousTypeCreationOptions()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AnonymousTypeCreationOptions"/> class with the specified parameters.
    /// </summary>
    /// <param name="name">The name to be used for the dynamically created anonymous type.</param>
    /// <param name="properties">The collection of property definitions for the dynamically created anonymous type.</param>
    /// <param name="genericTypeArguments">The generic type arguments for the dynamically created anonymous type.</param>
    /// <param name="useCache">Indicates whether to use a cache for storing and reusing dynamically created types.</param>
    /// <param name="createDefaultConstructor">Indicates whether to include a default constructor in the anonymous type.</param>
    /// <param name="createSetters">Indicates whether to create setters for the properties of the anonymous type.</param>
    public AnonymousTypeCreationOptions(
        string? name,
        IEnumerable<AnonymousPropertyDefinition> properties,
        Type[]? genericTypeArguments = null,
        bool useCache = true,
        bool createDefaultConstructor = false,
        bool createSetters = false)
    {
        Name = name ?? TypeCreator.AnonymousTypeDefaultName;
        Properties = properties;
        GenericTypeArguments = genericTypeArguments ?? Array.Empty<Type>();
        UseCache = useCache;
        CreateDefaultConstructor = createDefaultConstructor;
        CreateSetters = createSetters;
    }
}

