using Aidan.TextAnalysis.Language.Components;
using Aidan.TextAnalysis.Tokenization.Components;
using Aidan.TextAnalysis.Tokenization.Machine;
using System.Runtime.CompilerServices;

namespace Aidan.TextAnalysis.Tokenization;


/// <summary>
/// Represents a tokenizer that converts a source code string into a sequence of tokens.
/// </summary>
/// <remarks>
/// This is a hand-written, single threaded, (DFA) based tokenizer. It's tokenization process is fixed and cannot be dynamically modified by the user.
/// <br/>
/// The parsers in this library are designed to work with the tokens generated by this tokenizer. The tokenizer is optimized for performance and simplicity, focusing on the most common token patterns found in programming languages. 
/// It supports the following list of comment styles:
/// <list type="bullet">
/// <item>CPP style single-line comments: <c>// my comment...</c></item>
/// <item>CPP style multi-line comments: <c>/* my comment... */</c></item>
/// <item>EBNF style multi-line comments: <c>(* my comment... *)</c></item>
/// </list>
/// <br/>
/// Refer to <see cref="TokenType"/> for the list of supported token types, and their respective formation rules.
/// </remarks>
public class Tokenizer
{
    /*
     * Design Principles:
     * - Each state is encapsulated in a class that implements the IState interface.
     * - States are stateless, meaning they do not hold or manage any internal data between method invocations.
     * - Data required by states must be transient, passed only via method parameters. For managing state transitions and complex data flows, a 'context object' is utilized, which is propagated through the states.
     * - The tokenizer dynamically transitions between states based on the character input stream. Each state is designed to handle specific segments of the parsing process, such as numbers, identifiers, or string literals.
     * - States should primarily perform simple checks on the input stream, such as querying whether the current character is a digit or a letter.
     * - For each check, the state returns a transition object detailing the next state and the action required. This approach resembles a lookup table where the current state and input character determine the next state and action.
     * - Complex token patterns should be decomposed into simpler, more manageable states. For instance, a string recognition state may include sub-states for managing escape sequences or varying types of string delimiters (single or double quotes).
     */

    /// <summary>
    /// Gets the singleton instance of the Tokenizer class.
    /// </summary>
    public static Tokenizer Instance { get; } = new();

    private static InitialState InitialState { get; } = new();
    private static NumberZeroState NumberZeroState { get; } = new();
    private static IntegerNumberState IntegerNumberState { get; } = new();
    private static FloatNumberState FloatNumberState { get; } = new();
    private static HexadecimalNumberStartState HexadecimalNumberStartState { get; } = new();
    private static HexadecimalNumberState HexadecimalNumberState { get; } = new();

    private static SignState SignState { get; } = new();

    private static IdentifierState IdentifierState { get; } = new();
    private static PunctuationState PunctuationState { get; } = new();

    private static SingleQuoteStringState SingleQuoteStringState { get; } = new();
    private static SingleQuoteStringEscapeState SingleQuoteStringEscapeState { get; } = new();

    private static DoubleQuoteStringState DoubleQuoteStringState { get; } = new();
    private static DoubleQuoteStringEscapeState DoubleQuoteStringEscapeState { get; } = new();

    private static StringEndState StringEndState { get; } = new();

    private static CppStyleCommentStartState CppStyleCommentStartState { get; } = new();

    private static CppStyleSingleLineCommentState CppStyleSingleLineCommentState { get; } = new();

    private static CppStyleMultiLineCommentState CppStyleMultiLineCommentState { get; } = new();

    private static CppStyleMultiLineCommentEndConfirmState CppStyleMultiLineCommentEndConfirmState { get; } = new();

    private static EbnfStyleMultiLineCommentStartState EbnfStyleMultiLineCommentStartState { get; } = new();

    private static EbnfStyleMultiLineCommentState EbnfStyleMultiLineCommentState { get; } = new();

    private static EbnfStyleMultiLineCommentEndConfirmState EbnfStyleMultiLineCommentEndConfirmState { get; } = new();

    private static CommentEndState CommentEndState { get; } = new();

    /// <summary>
    /// Initializes a new instance of the Tokenizer class.
    /// </summary>
    public Tokenizer()
    {

    }

    /// <summary>
    /// Tokenizes the given source code string into a sequence of tokens.
    /// </summary>
    /// <param name="source">The source code string to tokenize.</param>
    /// <param name="includeEoi">Indicates whether to include an End of Input (EOI) token at the end of the token sequence.</param>
    /// <returns>An enumerable sequence of tokens.</returns>
    public IEnumerable<Token> Tokenize(
        string source,
        bool includeEoi = true)
    {
        var context = new LexicalContext(source);
        var currentState = InitialState as IState;

        while (true)
        {
            var transition = currentState.GetStateTransition(context.CurrentChar);

            switch (transition.Action)
            {
                case TokenizerAction.None:
                    break;

                case TokenizerAction.Read:
                    OnRead(context);
                    break;

                case TokenizerAction.Skip:
                    OnSkip(context);
                    break;

                case TokenizerAction.Emit:
                    yield return OnEmit(context, transition);
                    break;

                case TokenizerAction.Error:
                    OnError(context);
                    break;

                case TokenizerAction.End:
                    if (includeEoi)
                    {
                        yield return new Token(
                            type: TokenType.Eoi,
                            value: Eoi.SententialRepresentation.AsMemory(),
                            metadata: context.GetMetadata()
                        );
                    }
                    yield break;
            }

            switch (transition.NextState)
            {
                case TokenizerState.None:
                    break;

                case TokenizerState.Initial:
                    currentState = InitialState;
                    break;

                case TokenizerState.NumberZero:
                    currentState = NumberZeroState;
                    break;

                case TokenizerState.IntegerNumber:
                    currentState = IntegerNumberState;
                    break;

                case TokenizerState.FloatNumber:
                    currentState = FloatNumberState;
                    break;

                case TokenizerState.HexadecimalNumberStart:
                    currentState = HexadecimalNumberStartState;
                    break;

                case TokenizerState.HexadecimalNumber:
                    currentState = HexadecimalNumberState;
                    break;

                case TokenizerState.Sign:
                    currentState = SignState;
                    break;

                case TokenizerState.Identifier:
                    currentState = IdentifierState;
                    break;

                case TokenizerState.Punctuation:
                    currentState = PunctuationState;
                    break;

                case TokenizerState.SingleQuoteString:
                    currentState = SingleQuoteStringState;
                    break;

                case TokenizerState.SingleQuoteStringEscape:
                    currentState = SingleQuoteStringEscapeState;
                    break;

                case TokenizerState.DoubleQuoteString:
                    currentState = DoubleQuoteStringState;
                    break;

                case TokenizerState.DoubleQuoteStringEscape:
                    currentState = DoubleQuoteStringEscapeState;
                    break;

                case TokenizerState.StringEnd:
                    currentState = StringEndState;
                    break;

                case TokenizerState.CppStyleCommentStart:
                    currentState = CppStyleCommentStartState;
                    break;

                case TokenizerState.CppStyleSingleLineComment:
                    currentState = CppStyleSingleLineCommentState;
                    break;

                case TokenizerState.CppStyleMultiLineComment:
                    currentState = CppStyleMultiLineCommentState;
                    break;

                case TokenizerState.CppStyleMultiLineCommentEndConfirm:
                    currentState = CppStyleMultiLineCommentEndConfirmState;
                    break;

                case TokenizerState.EbnfStyleMultiLineCommentStart:
                    currentState = EbnfStyleMultiLineCommentStartState;
                    break;

                case TokenizerState.EbnfStyleMultiLineComment:
                    currentState = EbnfStyleMultiLineCommentState;
                    break;

                case TokenizerState.EbnfStyleMultiLineCommentEndConfirm:
                    currentState = EbnfStyleMultiLineCommentEndConfirmState;
                    break;

                case TokenizerState.CommentEnd:
                    currentState = CommentEndState;
                    break;

                default:
                    throw new InvalidOperationException();
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void OnRead(LexicalContext context)
    {
        context.Consume();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void OnSkip(LexicalContext context)
    {
        context.Skip();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Token OnEmit(LexicalContext context, ITransitionResult transition)
    {
        if (transition is not ITokenResult acceptingState)
        {
            throw new Exception($"Unexpected transition type '{transition.GetType().Name}'. Expected ITokenResult.");
        }

        var token = new Token(
            type: acceptingState.TokenType,
            value: context.AccumulatorValue,
            metadata: context.GetMetadata()
        );

        context.ResetAccumulator();
        return token;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void OnError(LexicalContext context)
    {
        throw new Exception($"Unexpected character '{context.CurrentChar}' at line {context.Line}, column {context.Column}.");
    }
}
